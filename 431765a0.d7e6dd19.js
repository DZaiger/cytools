(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{65:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return s}));var i=n(2),a=n(6),o=(n(0),n(84)),l={id:"triangulation",title:"Triangulation Class"},r={unversionedId:"documentation/triangulation",id:"documentation/triangulation",isDocsHomePage:!1,title:"Triangulation Class",description:"<link",source:"@site/docs/documentation/triangulation.md",slug:"/documentation/triangulation",permalink:"/docs/documentation/triangulation",version:"current",sidebar:"docs",previous:{title:"PolytopeFace Class",permalink:"/docs/documentation/polytopeface"},next:{title:"CalabiYau Class",permalink:"/docs/documentation/calabiyau"}},c=[{value:"Constructor",id:"constructor",children:[{value:"<code>cytools.triangulation.Triangulation</code>",id:"cytoolstriangulationtriangulation",children:[]}]},{value:"Functions",id:"functions",children:[{value:"<code>clear_cache</code>",id:"clear_cache",children:[]},{value:"<code>cpl_cone</code>",id:"cpl_cone",children:[]},{value:"<code>fan_cones</code>",id:"fan_cones",children:[]},{value:"<code>dim</code>",id:"dim",children:[]},{value:"<code>get_cy</code>",id:"get_cy",children:[]},{value:"<code>gkz_phi</code>",id:"gkz_phi",children:[]},{value:"<code>is_fine</code>",id:"is_fine",children:[]},{value:"<code>is_regular</code>",id:"is_regular",children:[]},{value:"<code>is_star</code>",id:"is_star",children:[]},{value:"<code>is_valid</code>",id:"is_valid",children:[]},{value:"<code>neighbor_triangulations</code>",id:"neighbor_triangulations",children:[]},{value:"<code>points</code>",id:"points",children:[]},{value:"<code>points_to_indices</code>",id:"points_to_indices",children:[]},{value:"<code>polytope</code>",id:"polytope",children:[]},{value:"<code>random_flips</code>",id:"random_flips",children:[]},{value:"<code>simplices</code>",id:"simplices",children:[]},{value:"<code>sr_ideal</code>",id:"sr_ideal",children:[]}]},{value:"Hidden Functions",id:"hidden-functions",children:[{value:"<code>__eq__</code>",id:"__eq__",children:[]},{value:"<code>__init__</code>",id:"__init__",children:[]},{value:"<code>__hash__</code>",id:"__hash__",children:[]},{value:"<code>__ne__</code>",id:"__ne__",children:[]},{value:"<code>__repr__</code>",id:"__repr__",children:[]}]}],b={rightToc:c};function s(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(i.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("link",{rel:"stylesheet",href:"https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css",integrity:"sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG",crossOrigin:"anonymous"}),Object(o.b)("p",null,"This class handles triangulations of lattice polytopes. It can analyze\nvarious aspects of the triangulation, as well as construct a CalabiYau\nobject if the triangulation is suitable."),Object(o.b)("div",{className:"admonition admonition-important alert alert--info"},Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(i.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(i.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(i.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"important")),Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Generally, objects of this class should not be constructed directly by the\nuser. Instead, they should be created by various functions of the\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"./polytope"}),"Polytope")," class."))),Object(o.b)("h2",{id:"constructor"},"Constructor"),Object(o.b)("h3",{id:"cytoolstriangulationtriangulation"},Object(o.b)("inlineCode",{parentName:"h3"},"cytools.triangulation.Triangulation")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nConstructs a ",Object(o.b)("inlineCode",{parentName:"p"},"Triangulation")," object describing a triangulation of a\nlattice polytope. This is handled by the hidden\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#__init__"}),Object(o.b)("inlineCode",{parentName:"a"},"__init__"))," function."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(i.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(i.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(i.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Some checks on the input are always performed, as it is nesessary to have\nall the data organized properly so that the results obtained with the\nCalabi-Yau class are correct. In particular, the ordering of the points\nneeds to be consistent with what the the ordering the\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"./polytope"}),"Polytope")," class uses. For this reason, this function first\nattempts to fix discrepancies, and if it fails then it disallows the\ncreation of a Calabi-Yau object."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"triang_pts")," (list): The list of points to be triangulated."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"poly")," (Polytope, optional): The ambient polytope of the points to be\ntriangulated. If not specified, it is constructed as the convex hull of\nthe given points."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"heights")," (list, optional): A list of heights specifying the regular\ntriangulation. When not secified, it will return the Delaunay\ntriangulation when using CGAL, a triangulation obtained from random\nheights near the Delaunay when using QHull, or the placing triangulation\nwhen using TOPCOM. Heights can only be specified when using CGAL or QHull\nas the backend."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"make_star")," (boolean, optional, default=False): Indicates whether to\nturn the triangulation into a star triangulation by deleting internal\nlines and connecting all points to the origin, or equivalently, by\ndecreasing the height of the origin until it is much lower than all other\nheights."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"simplices")," (list, optional): A list of simplices specifying the\ntriangulation. Each simplex is a list of point indices. This is useful\nwhen a triangulation was previously computed and it needs to be used\nagain. Note that the ordering of the points needs to be consistent."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"check_input_simplices")," (boolean, optional, default=True): Flag\nthat specifies whether to check if the input simplices define a valid\ntriangulation."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend"),' (string, optional, default="cgal"): Specifies the backend\nused to compute the triangulation.  The available options are "qhull",\n"cgal", and "topcom". CGAL is the default one as it is very\nfast and robust.')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Example:"),"\nWe construct a triangulation of a polytope. Since this class is not\nintended to by initialized by the end user, we create it via the\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"./polytope#triangulate"}),Object(o.b)("inlineCode",{parentName:"a"},"triangulate"))," function of the\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"./polytope"}),"Polytope")," class. In this example the polytope is reflexive, so\nby default the triangulation is fine, regular, and star."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-python",metastring:"{3}","{3}":!0}),"from cytools import Polytope\np = Polytope([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1],[-1,-1,-1,-1]])\nt = p.triangulate()\nt\n# Prints: A fine, regular, star triangulation of a 4-dimensional polytope in ZZ^4\n")),Object(o.b)("hr",null),Object(o.b)("h2",{id:"functions"},"Functions"),Object(o.b)("h3",{id:"clear_cache"},Object(o.b)("inlineCode",{parentName:"h3"},"clear_cache")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nClears the cached results of any previous computation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"recursive")," (boolean, optional, default=False): Whether to also\nclear the cache of the ambient polytope.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\nNothing."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"cpl_cone"},Object(o.b)("inlineCode",{parentName:"h3"},"cpl_cone")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nComputes the cone of strictly convex piecewise linear functions\ndefining the triangulation. It is computed by finding the defining\nhyperplane equations. The triangulation is regular if and only if this\ncone is solid (i.e. full-dimensional)."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"exclude_points_not_in_triangulation")," (boolean, optional,\ndefault=False): This flag allows the exclusion of points that are\nnot part of the triangulation. This can be done to check regularity\nfaster, but this cannot be used if the actual cone in the secondary\nfan is needed.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(Cone) The CPL cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"fan_cones"},Object(o.b)("inlineCode",{parentName:"h3"},"fan_cones")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nIt returns the cones forming a fan defined by a star triangulation of a\nreflexive polytope. The dimension of the desired cones can be\nspecified, and one can also restrict to cones that lie in faces of a\nparticular dimension."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"d")," (integer, optional): The dimension of the desired cones. If\nnot specified, it returns the full-dimensional cones."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"face_dim")," (integer, optional): Restricts to cones that lie on\nfaces of the polytope of a particular dimension. If not specified,\nthen no restriction is imposed.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The list of cones with the specified properties defined by the\nstar triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"dim"},Object(o.b)("inlineCode",{parentName:"h3"},"dim")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the dimension of the triangulation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(integer) The dimension of the triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"get_cy"},Object(o.b)("inlineCode",{parentName:"h3"},"get_cy")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns a CalabiYau object corresponding to the anti-canonical\nhypersurface on the toric variety defined by the fine, star, regular\ntriangulation."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(i.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(i.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(i.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Only Calabi-Yau 3-fold hypersurfaces are fully supported. Other\ndimensions require enabling experimetal features of CYTools."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(CalabiYau) The Calabi-Yau arising from the triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"gkz_phi"},Object(o.b)("inlineCode",{parentName:"h3"},"gkz_phi")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the GKZ phi vector of the triangulation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The GKZ phi vector of the triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_fine"},Object(o.b)("inlineCode",{parentName:"h3"},"is_fine")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the triangulation is fine (all the points are used),\nand False otherwise."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the triangulation being fine."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_regular"},Object(o.b)("inlineCode",{parentName:"h3"},"is_regular")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the triangulation is regular and False otherwise."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend")," (string, optional): The optimizer used for the\ncomputation. The available options are the backends of the\n",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"./cone#is_solid"}),Object(o.b)("inlineCode",{parentName:"a"},"is_solid"))," function of the\n",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"./cone"}),Object(o.b)("inlineCode",{parentName:"a"},"Cone"))," class. If not specified, it will be picked\nautomatically.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the triangulation being regular."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_star"},Object(o.b)("inlineCode",{parentName:"h3"},"is_star")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the triangulation is star and False otherwise."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the triangulation being star."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_valid"},Object(o.b)("inlineCode",{parentName:"h3"},"is_valid")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the presumed triangulation meets all requirements to be\na triangulation. The simplices must cover the full volume of the\nconvex hull, and they cannot intersect at full-dimensional regions."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the triangulation being valid."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"neighbor_triangulations"},Object(o.b)("inlineCode",{parentName:"h3"},"neighbor_triangulations")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the list of triangulations that differ by one bistellar flip\nfrom the current triangulation. The computation is performed with a\nmodified version of TOPCOM. There is the option of limiting the flips\nto fine, regular, and star triangulations. An additional backend is\nused to check regularity, as checking this with TOPCOM is very slow for\nlarge polytopes."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"only_fine")," (boolean, optional, default=False): Restricts to fine\ntriangulations."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"only_regular")," (boolean, optional, default=False): Restricts the\nto regular triangulations."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"only_star")," (boolean, optional, default=False): Restricts to star\ntriangulations."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend")," (string, optional, default=None): The backend used to\ncheck regularity. The options are any backend available for the\n",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"./cone#is_solid"}),Object(o.b)("inlineCode",{parentName:"a"},"is_solid"))," function of the\n",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"./cone"}),Object(o.b)("inlineCode",{parentName:"a"},"Cone"))," class.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The list of triangulations that differ by one bistellar flip\nfrom the current triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"points"},Object(o.b)("inlineCode",{parentName:"h3"},"points")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the points of the triangulation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The points of the triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"points_to_indices"},Object(o.b)("inlineCode",{parentName:"h3"},"points_to_indices")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the list of indices corresponding to the given points. It also\naccepts a single point, in which case it returns the corresponding\nindex."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"points")," (list): A list of points.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list or integer) The list of indices corresponding to the given\npoints. Or the index of the point if only one is given."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"polytope"},Object(o.b)("inlineCode",{parentName:"h3"},"polytope")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the polytope being triangulated."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(Polytope) The ambient polytope."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"random_flips"},Object(o.b)("inlineCode",{parentName:"h3"},"random_flips")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns a triangulation obtained by performing N random bistellar\nflips. The computation is performed with a modified version of TOPCOM.\nThere is the option of limiting the flips to fine, regular, and star\ntriangulations. An additional backend is used to check regularity, as\nchecking this with TOPCOM is very slow for large polytopes."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"N")," (integer): The number of bistellar flips to perform."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"only_fine")," (boolean, optional): Restricts to flips to fine\ntriangulations. If not specified, it is set to True if the\ntriangulation is fine, and False otherwise."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"only_regular")," (boolean, optional): Restricts the flips to\nregular triangulations. If not specified, it is set to True if the\ntriangulation is regular, and False otherwise."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"only_star")," (boolean, optional): Restricts the flips to star\ntriangulations. If not specified, it is set to True if the\ntriangulation is star, and False otherwise."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend")," (string, optional, default=None): The backend used to\ncheck regularity. The options are any backend available for the\n",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"./cone#is_solid"}),Object(o.b)("inlineCode",{parentName:"a"},"is_solid"))," function of the\n",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"./cone"}),Object(o.b)("inlineCode",{parentName:"a"},"Cone"))," class.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(Triangulation) A new triangulation obtained by performing N random\nflips."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"simplices"},Object(o.b)("inlineCode",{parentName:"h3"},"simplices")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the simplices of the triangulation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The simplices of the triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"sr_ideal"},Object(o.b)("inlineCode",{parentName:"h3"},"sr_ideal")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the Stanley-Reisner ideal if the triangulation is star."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The Stanley-Reisner ideal of the triangulation."),Object(o.b)("hr",null),Object(o.b)("h2",{id:"hidden-functions"},"Hidden Functions"),Object(o.b)("h3",{id:"__eq__"},Object(o.b)("inlineCode",{parentName:"h3"},"__eq__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nImplements comparison of triangulations with ==."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"other")," (Triangulation): The other triangulation that is being\ncompared.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the triangulations being equal."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__init__"},Object(o.b)("inlineCode",{parentName:"h3"},"__init__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nInitializes a ",Object(o.b)("inlineCode",{parentName:"p"},"Triangulation")," object."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"triang_pts")," (list): The list of points to be triangulated."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"poly")," (Polytope, optional): The ambient polytope of the points\nto be triangulated. If not specified, it is constructed as the convex\nhull of the given points."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"heights")," (list, optional): A list of heights specifying the\nregular triangulation. When not secified, it will return the Delaunay\ntriangulation when using CGAL, a triangulation obtained from random\nheights near the Delaunay when using QHull, or the placing\ntriangulation when using TOPCOM. Heights can only be specified when\nusing CGAL or QHull as the backend."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"make_star")," (boolean, optional, default=False): Indicates whether\nto turn the triangulation into a star triangulation by deleting\ninternal lines and connecting all points to the origin, or\nequivalently, by decreasing the height of the origin until it is much\nlower than all other heights."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"simplices")," (list, optional): A list of simplices specifying the\ntriangulation. Each simplex is a list of point indices. This is\nuseful when a triangulation was previously computed and it needs to\nbe used again. Note that the ordering of the points needs to be\nconsistent."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"check_input_simplices")," (boolean, optional, default=True): Flag\nthat specifies whether to check if the input simplices define a valid\ntriangulation."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend"),' (string, optional, default="cgal"): Specifies the\nbackend used to compute the triangulation.  The available options are\n"qhull", "cgal", and "topcom". CGAL is the default one as it is very\nfast and robust.')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\nNothing."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__hash__"},Object(o.b)("inlineCode",{parentName:"h3"},"__hash__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nImplements the ability to obtain hash values from triangulations."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(integer) The hash value of the triangulation."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__ne__"},Object(o.b)("inlineCode",{parentName:"h3"},"__ne__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nImplements comparison of triangulations with !=."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"other")," (Triangulation): The other triangulation that is being\ncompared.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the triangulations being different."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__repr__"},Object(o.b)("inlineCode",{parentName:"h3"},"__repr__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns a string describing the triangulation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(string) A string describing the triangulation."))}s.isMDXComponent=!0},84:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var i=n(0),a=n.n(i);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var b=a.a.createContext({}),s=function(e){var t=a.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return a.a.createElement(b.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),p=s(n),d=i,h=p["".concat(l,".").concat(d)]||p[d]||u[d]||o;return n?a.a.createElement(h,r(r({ref:t},b),{},{components:n})):a.a.createElement(h,r({ref:t},b))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=d;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var b=2;b<o;b++)l[b]=n[b];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);