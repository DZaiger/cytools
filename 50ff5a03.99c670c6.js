(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{66:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return s}));var a=n(2),i=n(6),o=(n(0),n(84)),c={id:"cone",title:"Cone Class"},r={unversionedId:"documentation/cone",id:"documentation/cone",isDocsHomePage:!1,title:"Cone Class",description:"<link",source:"@site/docs/documentation/cone.md",slug:"/documentation/cone",permalink:"/docs/documentation/cone",version:"current",sidebar:"docs",previous:{title:"CalabiYau Class",permalink:"/docs/documentation/calabiyau"},next:{title:"Miscellaneous Functions",permalink:"/docs/documentation/other"}},b=[{value:"Functions",id:"functions",children:[{value:"<code>ambient_dim</code>",id:"ambient_dim",children:[]},{value:"<code>clear_cache</code>",id:"clear_cache",children:[]},{value:"<code>dim</code>",id:"dim",children:[]},{value:"<code>dual</code>",id:"dual",children:[]},{value:"<code>extremal_rays</code>",id:"extremal_rays",children:[]},{value:"<code>hyperplanes</code>",id:"hyperplanes",children:[]},{value:"<code>intersection</code>",id:"intersection",children:[]},{value:"<code>is_pointed</code>",id:"is_pointed",children:[]},{value:"<code>is_simplicial</code>",id:"is_simplicial",children:[]},{value:"<code>is_smooth</code>",id:"is_smooth",children:[]},{value:"<code>is_solid</code>",id:"is_solid",children:[]},{value:"<code>rays</code>",id:"rays",children:[]},{value:"<code>tip_of_stretched_cone</code>",id:"tip_of_stretched_cone",children:[]}]},{value:"Hidden Functions",id:"hidden-functions",children:[{value:"<code>__eq__</code>",id:"__eq__",children:[]},{value:"<code>__hash__</code>",id:"__hash__",children:[]},{value:"<code>__init__</code>",id:"__init__",children:[]},{value:"<code>__ne__</code>",id:"__ne__",children:[]},{value:"<code>__repr__</code>",id:"__repr__",children:[]}]}],l={rightToc:b};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("link",{rel:"stylesheet",href:"https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css",integrity:"sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG",crossOrigin:"anonymous"}),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nConstructs a ",Object(o.b)("inlineCode",{parentName:"p"},"Cone")," object. This is handled by the hidden\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#__init__"}),Object(o.b)("inlineCode",{parentName:"a"},"__init__"))," function."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"rays")," (list, optional): A list of rays that generates the cone. If\nit is not specified then the hyperplane normals must be specified."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"hyperplanes")," (list, optional): A list of inward-pointing hyperplane\nnormals that define the cone. If it is not specified then the generating\nrays must be specified."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"check")," (boolean, optional): Whether to check the input. Recommended\nif constructing a cone directly.")),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"This class is primarily taylored to pointed (i.e. strongly convex) cones.\nThere are a few computations, such as finding extremal rays, that may\nproduce some unexpected results when working with non-pointed cones."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Example:"),"\nWe construct a cone in two different ways. First from a list of rays then\nfrom a list of hyperplane normals. We verify that the two inputs result in\nthe same cone."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python",metastring:"{2,3}","{2,3}":!0}),"from cytools import Cone\nc1 = Cone([[0,1],[1,1]])              # Create a cone using rays. It can also be done with Cone(rays=[[0,1],[1,1]])\nc2 = Cone(hyperplanes=[[1,0],[-1,1]]) # Ceate a cone using hyperplane normals.\nc1 == c2                              # We verify that the two cones are the same.\n# Prints: True\n")),Object(o.b)("hr",null),Object(o.b)("h2",{id:"functions"},"Functions"),Object(o.b)("h3",{id:"ambient_dim"},Object(o.b)("inlineCode",{parentName:"h3"},"ambient_dim")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the dimension of the ambient lattice."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(integer) The dimension of the ambient lattice."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"clear_cache"},Object(o.b)("inlineCode",{parentName:"h3"},"clear_cache")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nClears the cached results of any previous computation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\nNothing."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"dim"},Object(o.b)("inlineCode",{parentName:"h3"},"dim")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the dimension of the cone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(integer) The dimension of the cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"dual"},Object(o.b)("inlineCode",{parentName:"h3"},"dual")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the dual cone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(Cone) The dual cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"extremal_rays"},Object(o.b)("inlineCode",{parentName:"h3"},"extremal_rays")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the extremal rays of the cone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"tol")," (float, optional, default=1e-4): Specifies the tolerance\nfor deciding whether a ray is extremal or not."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"n_threads")," (integer, optional): Specifies the number of CPU\nthreads to be used in the computation. Using multiple threads can\ngreatly speed up the computation. If not specified, it is set to 1 if\nthe number of rays is small, and otherwise it is set to the number of\navailable CPU threads."),Object(o.b)("li",{parentName:"ul"},"verbose (boolean, optional, default=False): When set to True it show\nthe progress in finding the extremal rays.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The list of extremal rays of the cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"hyperplanes"},Object(o.b)("inlineCode",{parentName:"h3"},"hyperplanes")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the inward-pointing normals to the hyperplanes that define the\ncone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The list of inward-pointing normals to the hyperplanes that\ndefine the cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"intersection"},Object(o.b)("inlineCode",{parentName:"h3"},"intersection")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nComputes the intersection with another cone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"other")," (Cone or list): The other cone that is being intersected,\nor a list of cones to intersect with.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(Cone) The cone that results from the intersection."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_pointed"},Object(o.b)("inlineCode",{parentName:"h3"},"is_pointed")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the cone is pointed (i.e. strongly convex)."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"There are two available methods to perform the computation. Using NNLS\nit directly checks if it can find a linear subspace. Alternatively,\nit can check if the dual cone is solid. For extremely wide cones the\nsecond approach is more reliable, so that is the default one."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend"),' (string, optional): Specifies which backend to use.\nAvailable options are "nnls", and any backends available for the\n',Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#is_solid"}),Object(o.b)("inlineCode",{parentName:"a"},"is_solid"))," function. If not specified, it uses\nthe default backend for the ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#is_solid"}),Object(o.b)("inlineCode",{parentName:"a"},"is_solid"))," function."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"tol")," (float, optional, default=1e-7): The tolerance for\ndetermining when a linear subspace is found. This is only used for\nthe NNLS backend.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the cone being pointed."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_simplicial"},Object(o.b)("inlineCode",{parentName:"h3"},"is_simplicial")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the cone is simplicial."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the cone being simplicial."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_smooth"},Object(o.b)("inlineCode",{parentName:"h3"},"is_smooth")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the cone is smooth, i.e. its extremal rays either form\na basis of the ambient lattice, or they can be extended into one."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the cone being smooth."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"is_solid"},Object(o.b)("inlineCode",{parentName:"h3"},"is_solid")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns True if the cone is solid, i.e. if it is full-dimensional."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"If the generating rays are known then this can simply be checked by\ncomputing the dimension of the linear space that they span. However,\nwhen only the hyperplane inequalities are known this can be a difficult\nproblem. When using PPL as the backend, the convex hull is explicitly\nconstructed and checked. The other backends try to solve an\noptimization problem inside the stretched cone, which fails if the cone\nis not solid. The latter approach is much faster, but there can be\nextremely narrow cones where the optimization fails and this function\nreturns a false negative. Mosek is recommended when using such\nextremely narrow cones."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend"),' (string, optional): Specifies which backend to use.\nAvailable options are "ppl", "ortools", and any backends available\nfor the ',Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#tip_of_stretched_cone"}),Object(o.b)("inlineCode",{parentName:"a"},"tip_of_stretched_cone")),"\nfunction. If not specified, it uses Mosek if it is activated, or\nORTools otherwise."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"c")," (float, optional, default=0.01): A number used to create the\nstretched cone and try to find the tip. This is ignored when using\nPPL as the backend.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the cone being solid."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"rays"},Object(o.b)("inlineCode",{parentName:"h3"},"rays")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nReturns the (not necessarily extremal) rays that generate the cone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(list) The list of rays that generate the cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"tip_of_stretched_cone"},Object(o.b)("inlineCode",{parentName:"h3"},"tip_of_stretched_cone")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nFinds the tip of the stretched cone via quadratic programming. The\nstretched cone is defined as the convex polyhedral region inside the\ncone that is at least a distance ",Object(o.b)("inlineCode",{parentName:"p"},"c")," from any of its defining\nhyperplanes."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"c")," (float): A real positive number specifying the stretching of\nthe cone (i.e. the minimum distance to the defining hyperplanes)."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"backend"),' (string, optional, default="all"): String that\nspecifies the optimizer to use. Options are "all", "mosek" and\n"cvxopt".'),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"checks")," (boolean, optional, default=True): Flag that specifies\nwhether to check if the output of the optimizer is consistent and\nsatisfies constraint_error_tol."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"constraint_error_tol")," (float, optional, default=1e-4): Error\ntolerence for the linear constraints."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"verbose")," (integer, optional, default=0): The verbosity level.",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"verbose = 0: Do not print anything."),Object(o.b)("li",{parentName:"ul"},"verbose = 1: Print warnings when optimizers fail.")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(tuple) A tuple with two components. The first one is a float that\nspecifies the distance to the tip of the stretched cone, and the second\none is a vector specifying the location."),Object(o.b)("hr",null),Object(o.b)("h2",{id:"hidden-functions"},"Hidden Functions"),Object(o.b)("h3",{id:"__eq__"},Object(o.b)("inlineCode",{parentName:"h3"},"__eq__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nImplements comparison of cones with ==."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"The comparison of cones that are not pointed, and whose duals are also\nnot pointed, is not supported."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"other")," (Cone): The other cone that is being compared.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the cones being equal."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__hash__"},Object(o.b)("inlineCode",{parentName:"h3"},"__hash__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nImplements the ability to obtain hash values from cones."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Cones that are not pointed, and whose duals are also not pointed, are\nnot supported."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:"),"\nNone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(integer) The hash value of the cone."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__init__"},Object(o.b)("inlineCode",{parentName:"h3"},"__init__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nInitializes a ",Object(o.b)("inlineCode",{parentName:"p"},"Cone")," object."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"rays")," (list, optional): A list of rays that generates the cone.\nIf it is not specified then the hyperplane normals must be specified."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"hyperplanes")," (list, optional): A list of inward-pointing\nhyperplane normals that define the cone. If it is not specified then\nthe generating rays must be specified."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"check")," (boolean, optional): Whether to check the input.\nRecommended if constructing a cone directly.")),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Exactly one of ",Object(o.b)("inlineCode",{parentName:"p"},"rays")," or ",Object(o.b)("inlineCode",{parentName:"p"},"hyperplanes")," must be specified.\nOtherwise an exception is raised."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\nNothing."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__ne__"},Object(o.b)("inlineCode",{parentName:"h3"},"__ne__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:"),"\nImplements comparison of cones with !=."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"The comparison of cones that are not pointed, and whose duals are also\nnot pointed, is not supported."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"other")," (Cone): The other cone that is being compared.")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns:"),"\n(boolean) The truth value of the cones being different."),Object(o.b)("hr",null),Object(o.b)("h3",{id:"__repr__"},Object(o.b)("inlineCode",{parentName:"h3"},"__repr__")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Description:")," Returns a string describing the cone."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments:")," None."))}s.isMDXComponent=!0},84:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function b(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),s=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=b(e,["components","mdxType","originalType","parentName"]),p=s(n),h=a,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||o;return n?i.a.createElement(m,r(r({ref:t},l),{},{components:n})):i.a.createElement(m,r({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,c=new Array(o);c[0]=h;var r={};for(var b in t)hasOwnProperty.call(t,b)&&(r[b]=t[b]);r.originalType=e,r.mdxType="string"==typeof e?e:a,c[1]=r;for(var l=2;l<o;l++)c[l]=n[l];return i.a.createElement.apply(null,c)}return i.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);