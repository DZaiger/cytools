(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),s=(n(0),n(84)),i={id:"experimental",title:"Experimental Features"},o={unversionedId:"documentation/experimental",id:"documentation/experimental",isDocsHomePage:!1,title:"Experimental Features",description:"<link",source:"@site/docs/documentation/experimental.md",slug:"/documentation/experimental",permalink:"/docs/documentation/experimental",version:"current",sidebar:"docs",previous:{title:"Configuration",permalink:"/docs/documentation/config"},next:{title:"Licensing",permalink:"/docs/documentation/license"}},c=[{value:"Calabi-Yau hypersurfaces of dimensions other than 3",id:"calabi-yau-hypersurfaces-of-dimensions-other-than-3",children:[]},{value:"Generic bases for divisors and curves",id:"generic-bases-for-divisors-and-curves",children:[]},{value:"Rational intersection numbers of singular varieties or Calabi-Yau hypersurfaces",id:"rational-intersection-numbers-of-singular-varieties-or-calabi-yau-hypersurfaces",children:[]}],l={rightToc:c};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("link",{rel:"stylesheet",href:"https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css",integrity:"sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG",crossOrigin:"anonymous"}),Object(s.b)("h2",{id:"calabi-yau-hypersurfaces-of-dimensions-other-than-3"},"Calabi-Yau hypersurfaces of dimensions other than 3"),Object(s.b)("p",null,"There is experimental support for Calabi-Yaus of dimensions other than 3. They can be constructed in the analogous way by starting with reflexive polytopes in dimensions other than 5. As the simplest example, we can construct the hypersurface in ",Object(s.b)("span",Object(a.a)({parentName:"p"},{className:"math math-inline"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(s.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("msup",{parentName:"mrow"},Object(s.b)("mi",Object(a.a)({parentName:"msup"},{mathvariant:"double-struck"}),"P"),Object(s.b)("mn",{parentName:"msup"},"5"))),Object(s.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\mathbb{P}^5")))),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.8141079999999999em",verticalAlign:"0em"}})),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"mord"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"mord"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathbb"}),"P")),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"msupsub"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"vlist-t"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"vlist-r"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"vlist",style:{height:"0.8141079999999999em"}}),Object(s.b)("span",Object(a.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(s.b)("span",Object(a.a)({parentName:"span"},{className:"mord mtight"}),"5")))))))))))),"."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"from cytools import config, Polytope\nconfig.enable_experimental_features = True\np = Polytope([[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[-1,-1,-1,-1,-1]])\nt = p.triangulate()\ncy = t.get_cy()\ncy\n# Prints: A Calabi-Yau 4-fold hypersurface with h11=1, h12=0, h13=426, and h22=1752 in a 5-dimensional toric variety.\n")),Object(s.b)("p",null,"Most of the functions such as the ambient Mori cone or the intersection numbers should work well, but we can't guarantee that there won't be problems."),Object(s.b)("h2",{id:"generic-bases-for-divisors-and-curves"},"Generic bases for divisors and curves"),Object(s.b)("p",null,"The only kind of basis that are fully supported are those formed from a subset of prime effectic toric divisors. However, there is experimental support for generic basis that are specified with a matrix where each row is a linear combination of the canonical divisor, and the prime effective divisors (or the canonical divisor can be left out). We can see this in the following example."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"from cytools import config, Polytope\nconfig.enable_experimental_features = True\np = Polytope([[-1,3,-2,-1],[1,-1,0,0],[-1,0,0,1],[-1,0,0,0],[-1,0,1,1],[-1,0,2,0]])\nt = p.triangulate()\ncy = t.get_cy()\ncy.divisor_basis()\n# Prints: array([5, 6, 7])\nbasis = [[0,0,0,0,0,1,0,0],  # Same basis, but in matrix form\n         [0,0,0,0,0,0,1,0],\n         [0,0,0,0,0,0,0,1]]\ncy.set_divisor_basis(basis)  # Now has the same basis, but behavior is different\nbasis = [[0,0,0,0,1,0,0],  # The canonical divisor can be omitted\n         [0,0,0,0,0,1,0],\n         [0,0,0,0,0,0,1]]\ncy.set_divisor_basis(basis) # The basis is still the same\nbasis = [[0,1,0,0,1,0,1],  # A more generic basis choice\n         [0,0,2,0,0,1,0],\n         [0,0,0,3,0,1,1]]\ncy.set_divisor_basis(basis)\n")),Object(s.b)("p",null,"In this snippet we saw that the basis that was chosen automatically was composed of the prime toric divisors with index 5, 6 and 7. We wrote the same basis, but now in matrix form. Of course, a more generic choice can be made, which is what is done afterwards."),Object(s.b)("p",null,"An important thing to keep in mind is that when intersection numbers are computed in these generic bases, they will be computed as floating-point numbers, since there is a good chance that some intersection numbers will be very large and they will overflow 64-bit integers. Also, the intersection tensor in these bases will be given as a dense array instead of a sparse one."),Object(s.b)("p",null,"A similar thing can be done for curves. We show an example of this."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"from cytools import config, Polytope\nconfig.enable_experimental_features = True\np = Polytope([[-1,3,-2,-1],[1,-1,0,0],[-1,0,0,1],[-1,0,0,0],[-1,0,1,1],[-1,0,2,0]])\nt = p.triangulate()\ncy = t.get_cy()\nbasis = cy.ambient_mori_cone(in_basis=False).extremal_rays()\ncy.set_curve_basis(basis)\ncy.ambient_mori_cone(in_basis=True).extremal_rays()\n# Prints: array([[1, 0, 0],\n#                [0, 1, 0],\n#                [0, 0, 1]])\n")),Object(s.b)("p",null,"This example works because the ambient Mori cone is simplicial and smooth, so we can pick the extremal rays as a basis for curves. If we compute the Mori cone again in this basis we obtain the first octant, as expected."),Object(s.b)("p",null,"Finally, we mention that there is the option of using exact rational arithmetic when using generic bases. This is done using the Flint classes ",Object(s.b)("inlineCode",{parentName:"p"},"fmpz")," and ",Object(s.b)("inlineCode",{parentName:"p"},"fmpq"),". The computations may take extremely long or even run out of memory when dealing with very large polytopes. We can illustrate this with the above example."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"from cytools import config, Polytope\nconfig.enable_experimental_features = True\np = Polytope([[-1,3,-2,-1],[1,-1,0,0],[-1,0,0,1],[-1,0,0,0],[-1,0,1,1],[-1,0,2,0]])\nt = p.triangulate()\ncy = t.get_cy()\nbasis = cy.ambient_mori_cone(in_basis=False).extremal_rays()\ncy.set_curve_basis(basis, exact_arithmetic=True)\ncy.divisor_basis()\n# Prints: array([[-7/11, -1, -7/11, -7/11, -2/11, 16/11, 18/11, 0],\n#                [-2/11, 0, -2/11, -2/11, 1/11, 3/11, 2/11, 0],\n#                [-8/11, -1, -8/11, -8/11, 4/11, 12/11, 19/11, 0]], dtype=object)\n")),Object(s.b)("h2",{id:"rational-intersection-numbers-of-singular-varieties-or-calabi-yau-hypersurfaces"},"Rational intersection numbers of singular varieties or Calabi-Yau hypersurfaces"),Object(s.b)("p",null,"By default, intersection numbers of the ambient varieties are computed as floating-point numbers, and so are the intersection numbers of singular CY hypersurfaces. There is the option of transforming them into exact rational numbers. The conversion doesn't take too long, but verifying it was successful can be very slow or even run out of memory. Here we look at a simple example."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"from cytools import config, Polytope\nconfig.enable_experimental_features = True\np = Polytope([[-1,3,-2,-1],[1,-1,0,0],[-1,0,0,1],[-1,0,0,0],[-1,0,1,1],[-1,0,2,0]])\nt = p.triangulate()\ncy = t.get_cy()\ncy.ambient_intersection_numbers(exact_arithmetic=True)\n# Prints: array([[0, 0, 0, 0, 648],\n#               [0, 0, 0, 1, -324],\n#               [0, 0, 0, 2, -108],\n#               ...,\n#               [6, 6, 7, 7, -2/3],\n#               [6, 7, 7, 7, 4/3],\n#               [7, 7, 7, 7, -10/3]], dtype=object)\n")),Object(s.b)("p",null,"For large polytopes one can disable the check for consistency with ",Object(s.b)("inlineCode",{parentName:"p"},"check=False"),", but this is strongly discouraged since the conversion to rationals tends to be unreliable for large polytopes."))}p.isMDXComponent=!0},84:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},b=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,h=b["".concat(i,".").concat(u)]||b[u]||m[u]||s;return n?r.a.createElement(h,o(o({ref:t},l),{},{components:n})):r.a.createElement(h,o({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);